// This client was generated by Platformatic from an OpenAPI specification.

import type { Client } from './client-types'
import type * as Types from './client-types'

// The base URL for the API. This can be overridden by calling `setBaseUrl`.
let baseUrl = ''
// The default headers to send within each request. This can be overridden by calling `setDefaultHeaders`.
let defaultHeaders = {}

function sanitizeUrl(url: string) : string {
  if (url.endsWith('/')) { return url.slice(0, -1) } else { return url }
}
export const setBaseUrl = (newUrl: string) : void => { baseUrl = sanitizeUrl(newUrl) }

export const setDefaultHeaders = (headers: Object): void => { defaultHeaders = headers }

type JSON = Record<string, unknown>
/* @ts-ignore */
function headersToJSON(headers: Headers): JSON {
  const output: JSON = {}
  headers.forEach((value, key) => {
    output[key] = value
  })
  return output
}

const _getApiRuntimes = async (url: string, request: Types.GetApiRuntimesRequest): Promise<Types.GetApiRuntimesResponses> => {
  const queryParameters: (keyof Types.GetApiRuntimesRequest)[]  = ['includeAdmin']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        (request[qp] as string[]).forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/api/runtimes?${searchParams.toString()}`, {
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type').startsWith('application/json')) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.json() as any
    }
  }
  return {
    statusCode: response.status as 200,
    headers: headersToJSON(response.headers),
    body: await response.text() as any
  }
}

export const getApiRuntimes: Client['getApiRuntimes'] = async (request: Types.GetApiRuntimesRequest): Promise<Types.GetApiRuntimesResponses> => {
  return await _getApiRuntimes(baseUrl, request)
}
const _getApiRuntimesPidMetrics = async (url: string, request: Types.GetApiRuntimesPidMetricsRequest): Promise<Types.GetApiRuntimesPidMetricsResponses> => {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/api/runtimes/${request['pid']}/metrics`, {
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type').startsWith('application/json')) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.json() as any
    }
  }
  return {
    statusCode: response.status as 200,
    headers: headersToJSON(response.headers),
    body: await response.text() as any
  }
}

export const getApiRuntimesPidMetrics: Client['getApiRuntimesPidMetrics'] = async (request: Types.GetApiRuntimesPidMetricsRequest): Promise<Types.GetApiRuntimesPidMetricsResponses> => {
  return await _getApiRuntimesPidMetrics(baseUrl, request)
}
const _getApiRuntimesPidMetricsServiceId = async (url: string, request: Types.GetApiRuntimesPidMetricsServiceIdRequest): Promise<Types.GetApiRuntimesPidMetricsServiceIdResponses> => {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/api/runtimes/${request['pid']}/metrics/${request['serviceId']}`, {
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type').startsWith('application/json')) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.json() as any
    }
  }
  return {
    statusCode: response.status as 200,
    headers: headersToJSON(response.headers),
    body: await response.text() as any
  }
}

export const getApiRuntimesPidMetricsServiceId: Client['getApiRuntimesPidMetricsServiceId'] = async (request: Types.GetApiRuntimesPidMetricsServiceIdRequest): Promise<Types.GetApiRuntimesPidMetricsServiceIdResponses> => {
  return await _getApiRuntimesPidMetricsServiceId(baseUrl, request)
}
const _getApiRuntimesPidServices = async (url: string, request: Types.GetApiRuntimesPidServicesRequest): Promise<Types.GetApiRuntimesPidServicesResponses> => {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/api/runtimes/${request['pid']}/services`, {
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type').startsWith('application/json')) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.json() as any
    }
  }
  return {
    statusCode: response.status as 200,
    headers: headersToJSON(response.headers),
    body: await response.text() as any
  }
}

export const getApiRuntimesPidServices: Client['getApiRuntimesPidServices'] = async (request: Types.GetApiRuntimesPidServicesRequest): Promise<Types.GetApiRuntimesPidServicesResponses> => {
  return await _getApiRuntimesPidServices(baseUrl, request)
}
const _getApiRuntimesPidOpenapiServiceId = async (url: string, request: Types.GetApiRuntimesPidOpenapiServiceIdRequest): Promise<Types.GetApiRuntimesPidOpenapiServiceIdResponses> => {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/api/runtimes/${request['pid']}/openapi/${request['serviceId']}`, {
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type').startsWith('application/json')) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.json() as any
    }
  }
  return {
    statusCode: response.status as 200,
    headers: headersToJSON(response.headers),
    body: await response.text() as any
  }
}

export const getApiRuntimesPidOpenapiServiceId: Client['getApiRuntimesPidOpenapiServiceId'] = async (request: Types.GetApiRuntimesPidOpenapiServiceIdRequest): Promise<Types.GetApiRuntimesPidOpenapiServiceIdResponses> => {
  return await _getApiRuntimesPidOpenapiServiceId(baseUrl, request)
}
const _postApiRuntimesPidReload = async (url: string, request: Types.PostApiRuntimesPidReloadRequest): Promise<Types.PostApiRuntimesPidReloadResponses> => {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/api/runtimes/${request['pid']}/reload`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type').startsWith('application/json')) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.json() as any
    }
  }
  return {
    statusCode: response.status as 200,
    headers: headersToJSON(response.headers),
    body: await response.text() as any
  }
}

export const postApiRuntimesPidReload: Client['postApiRuntimesPidReload'] = async (request: Types.PostApiRuntimesPidReloadRequest): Promise<Types.PostApiRuntimesPidReloadResponses> => {
  return await _postApiRuntimesPidReload(baseUrl, request)
}
const _postApiRuntimesPidRestart = async (url: string, request: Types.PostApiRuntimesPidRestartRequest): Promise<Types.PostApiRuntimesPidRestartResponses> => {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/api/runtimes/${request['pid']}/restart`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type').startsWith('application/json')) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.json() as any
    }
  }
  return {
    statusCode: response.status as 200,
    headers: headersToJSON(response.headers),
    body: await response.text() as any
  }
}

export const postApiRuntimesPidRestart: Client['postApiRuntimesPidRestart'] = async (request: Types.PostApiRuntimesPidRestartRequest): Promise<Types.PostApiRuntimesPidRestartResponses> => {
  return await _postApiRuntimesPidRestart(baseUrl, request)
}
const _postApiRuntimesPidStop = async (url: string, request: Types.PostApiRuntimesPidStopRequest): Promise<Types.PostApiRuntimesPidStopResponses> => {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/api/runtimes/${request['pid']}/stop`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type').startsWith('application/json')) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.json() as any
    }
  }
  return {
    statusCode: response.status as 200,
    headers: headersToJSON(response.headers),
    body: await response.text() as any
  }
}

export const postApiRuntimesPidStop: Client['postApiRuntimesPidStop'] = async (request: Types.PostApiRuntimesPidStopRequest): Promise<Types.PostApiRuntimesPidStopResponses> => {
  return await _postApiRuntimesPidStop(baseUrl, request)
}
type BuildOptions = {
  headers?: Object
}
export default function build (url: string, options?: BuildOptions) {
  url = sanitizeUrl(url)
  if (options?.headers) {
    defaultHeaders = options.headers
  }
  return {
    getApiRuntimes: _getApiRuntimes.bind(url, ...arguments),
    getApiRuntimesPidMetrics: _getApiRuntimesPidMetrics.bind(url, ...arguments),
    getApiRuntimesPidMetricsServiceId: _getApiRuntimesPidMetricsServiceId.bind(url, ...arguments),
    getApiRuntimesPidServices: _getApiRuntimesPidServices.bind(url, ...arguments),
    getApiRuntimesPidOpenapiServiceId: _getApiRuntimesPidOpenapiServiceId.bind(url, ...arguments),
    postApiRuntimesPidReload: _postApiRuntimesPidReload.bind(url, ...arguments),
    postApiRuntimesPidRestart: _postApiRuntimesPidRestart.bind(url, ...arguments),
    postApiRuntimesPidStop: _postApiRuntimesPidStop.bind(url, ...arguments)
  }
}